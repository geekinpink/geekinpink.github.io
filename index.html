<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题准备 | Hello VuePress</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.c939f5a5.js" as="script"><link rel="preload" href="/assets/js/2.24b011f1.js" as="script"><link rel="preload" href="/assets/js/7.2d3061fb.js" as="script"><link rel="prefetch" href="/assets/js/3.5b37e6aa.js"><link rel="prefetch" href="/assets/js/4.fbcf4621.js"><link rel="prefetch" href="/assets/js/5.ec4b3f90.js"><link rel="prefetch" href="/assets/js/6.27888615.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" aria-current="page" class="home-link router-link-exact-active router-link-active"><!----> <span class="site-name">Hello VuePress</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="面试题准备"><a href="#面试题准备" class="header-anchor">#</a> 面试题准备</h3> <h4 id="算法"><a href="#算法" class="header-anchor">#</a> 算法</h4> <ol><li>DFS，BFS
<ol><li>二叉树层序遍历</li> <li>前中后遍历（迭代/递归）</li></ol></li> <li>快排</li> <li>快慢指针
<ol><li>快乐数</li></ol></li> <li>双指针
<ol><li>三数字之和</li></ol></li> <li>hash 表
<ol><li>最长连续上升子序列</li></ol></li> <li>异或
<ol><li>不借助变量交换两数</li></ol></li> <li>回溯
<ol><li>括号生成</li> <li>全排列</li> <li>数组子集</li></ol></li> <li>动态规划
<ol><li>最长上升序列长度</li> <li>矩阵最短路径</li></ol></li> <li>分治</li> <li>贪心
<ol><li>股票买卖</li></ol></li> <li>链表
<ol><li>反转链表</li></ol></li></ol> <h3 id="知识体系"><a href="#知识体系" class="header-anchor">#</a> 知识体系</h3> <h4 id="样式相关"><a href="#样式相关" class="header-anchor">#</a> 样式相关</h4> <ol><li>基础：盒子模型，浮动，BFC，flex：
<ol><li>BFC：块级格式化上下文。应用：清除浮动，margin 重合等。</li> <li>垂直居中：使用 flex。</li> <li>画形状：扇形，三角形，椭圆</li> <li>flex：主轴，交叉轴，对齐，换行，放大缩小比例。</li></ol></li> <li>动画相关：frame 动画，css 动画，animation。</li></ol> <h4 id="ts-基础"><a href="#ts-基础" class="header-anchor">#</a> TS 基础</h4> <ol><li><p>unknown 和 any：推荐使用 unknow，它提供了安全的类型，有更好的类型收窄功能。</p></li> <li><p>TS 中的 OOP</p> <ol><li>OOP 三大特点：封装，继承，多态</li> <li>interface 可以用于 implements</li> <li></li></ol></li> <li><p>Decorator</p> <ol><li>实验性特性，es 也是提案中。</li></ol></li> <li><p>泛型的理解</p> <ol><li><p>更加灵活的定义，和重用性，不必指定特定类型。</p></li> <li><p>可以做到有意义的收束。</p> <ol><li><p>extends，keyof 等</p></li> <li><p>提供默认类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> a<span class="token operator">:</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">'string'</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> a1<span class="token operator">:</span> <span class="token constant">A</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
</code></pre></div></li> <li><p>泛型条件类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">stringPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;Hello, Semlinker!&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">personPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;Semlinker&quot;</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span> <span class="token keyword">as</span> Person<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">PromiseType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">UnPromisify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">PromiseType<span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">extractStringPromise</span> <span class="token operator">=</span> UnPromisify<span class="token operator">&lt;</span><span class="token keyword">typeof</span> stringPromise<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name">extractPersonPromise</span> <span class="token operator">=</span> UnPromisify<span class="token operator">&lt;</span><span class="token keyword">typeof</span> personPromise<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Person</span>
</code></pre></div></li> <li><p>泛型工具类型</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span>  <span class="token punctuation">{</span>
	<span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol></li></ol></li></ol> <h4 id="js基础"><a href="#js基础" class="header-anchor">#</a> JS基础</h4> <ol><li>EventLoop：微任务，宏任务
<ol><li>描述：js 运行时环境包括了堆，栈，队列。</li> <li>JS 是单线程，如果所有任务都排队执行则阻塞。所以有同步任务和异步任务，EventLoop 处理异步任务的调度机制。在执行完同步任务，则会从任务队列中出队执行。</li> <li>microtask 和 macrotask 区别。</li></ol></li> <li>数据类型：基础，引用，垃圾回收，内存泄漏
<ol><li>类型检测方式：Object.prototype.toString.call</li> <li>constructor 判断</li></ol></li> <li>原型链，继承，作用域
<ol><li>new，instanceof 的实现
<ul><li>new：创建对象；对象原型指向构造器的原型；调用构造器，this 绑定刚创建的对象；如果构造器返回对象，则返回它，否则返回一开始创建的对象。</li> <li>instanceof：沿着__proto__链找，要么最后为 null，要么等于目标 prototype。</li></ul></li> <li>this 指向问题，call，apply 等的实现</li> <li>深克隆（特殊类型（Date，RegExp）考虑，循环应用问题）</li></ol></li> <li>异步编程：Promise，async / await
<ol><li>并发控制（利用 race 和 all）</li></ol></li> <li>函数式编程：1. 柯里化 2.高阶函数 3. 闭包
<ol><li>应用：节流、防抖 （立即执行版本）</li> <li>currying 实现</li> <li>闭包是和其周围的环境引用绑定的函数 它能访问其外层的作用域</li></ol></li> <li>常用的 ES6+：let const 模板字符串 箭头函数 数组/对象解构 optional chaining 空对象合并符 Promise async await Set Map 等</li></ol> <h4 id="前端模块化"><a href="#前端模块化" class="header-anchor">#</a> 前端模块化</h4> <ol><li>解决了作用域问题，通过文件系统为代码做合理分隔，并且不会污染全局环境</li> <li>ESM，CommonJS，AMD（require.js），CMD（sea.js），UMD，IIFE
<ol><li>ESM 静态依赖分析</li> <li>CommonJS 运行时依赖确定</li></ol></li></ol> <h4 id="浏览器相关"><a href="#浏览器相关" class="header-anchor">#</a> 浏览器相关</h4> <ol><li>perfermance</li> <li>缓存机制
<ol><li>强缓存：cache-control / expires，是否过期判断，如果没有则返回200，从浏览器的 memory 或者 disk 中读取。</li> <li>协商缓存：浏览器发送 e-tag / last-modified 字段给浏览器，浏览器第二次请求带上 if-none-match / if-modified-since，校验新鲜度，需要缓存则返回304 读取缓存。</li></ol></li></ol> <h4 id="框架"><a href="#框架" class="header-anchor">#</a> 框架</h4> <ol><li>Vue 的响应式原理？
<ol><li>通过 Object.defineProperty 去拦截对象的 getter / setter，当 render 函数中访问了对应的 data，data 上的每个属性都会递归收集依赖，通过 dep 对象的 depend 方法，订阅了当前的 watcher ，当修改 data 时，触发 setter，调用了 dep 对象的 notify 方法，则触发了订阅 watcher 的重新计算。</li></ol></li> <li>Vue 3有些什么新特性？
<ol><li>整体架构重新设计，各模块采用 monorepo 管理，ts 重写，支持  tree shaking</li> <li>VCA 的支持，新增了 teleport，fragment 等新组件</li> <li>响应式系统重写，Proxy 代替了原来。</li> <li>Diff 优化：编译静态提升，事件缓存。</li></ol></li> <li>keep-alive 原理</li> <li>Vue 的编译原理？
<ol><li>parser  -&gt; optimizer -&gt; codegen：首先对模板进行解析，生成 AST；AST 优化，标记静态节点，以优化 diff；最后生成 render 函数。</li></ol></li> <li>Vue Computed 原理？
<ol><li>Vue 初始化时，会为每个 computed 值创建一个渲染 watcher，并且将 computed 值代理到 vm 上，并且 getter 是对当前渲染 watcher 的计算。</li> <li>当渲染 watcher 计算时，触发了对应的 data 的getter，再次收集依赖，depend 到该 watcher。这样 computed watcher 就订阅了依赖的 data 的变化了。</li></ol></li> <li>diff 算法的描述？时间复杂度？
<ol><li>同层比较，四个指针移动比较，</li></ol></li></ol> <h4 id="网络相关"><a href="#网络相关" class="header-anchor">#</a> 网络相关</h4> <h5 id="登录原理"><a href="#登录原理" class="header-anchor">#</a> 登录原理</h5> <ol><li>cookie + sessionId：服务器验证成功后，通过 set-cookie 将 sessionId 种入 cookie，再次登录的时候带上 cookie 验证。问题：不能防止 CSRF 攻击，性能差（服务器需要存储）。</li> <li>Token：登录成功产生 token，token 由<strong>客户端存储</strong>，再次登录的时候带上 token，服务器进行验证。JWT 签名算法：
<ol><li>token 包括了 header（指定加密算法）， payload（指定 token 生成时间），signature (通过 header 和 payload 配合服务器的私钥生成)。</li> <li>生成的 token 通过同样的算法，可以生成相同的签名，如果签名一致，并且没有过期，则通过鉴权。</li></ol></li> <li>单点登录：a.com 未鉴权时候，302重定向到 sso 登录页，登录成功后带上 ticket 跳转至 a.com 的验证接口，并且 sso 种上了 cookie，然后 a.com 创建会话，种上 sessionId，这样就登录完成。</li></ol> <h5 id="短链原理"><a href="#短链原理" class="header-anchor">#</a> 短链原理</h5> <ol><li>随机生成 对应一个 id</li></ol> <h4 id="http-相关"><a href="#http-相关" class="header-anchor">#</a> http 相关</h4> <h5 id="基础知识"><a href="#基础知识" class="header-anchor">#</a> 基础知识</h5> <ol><li>报文组成：请求/响应行 + 请求/响应头 + 空行 + 请求体/响应体</li> <li>POST 和 GET 的区别：缓存 编码 参数 幂等</li> <li>常用状态码：200，301（永久重定向），302（暂时重定向），304（命中协商缓存），401，404，500。</li> <li>cookie：secure（只能 https 传输），SameSite（防范 CSRF），HttpOnly（防范 XSS）。</li> <li>CORS：简单请求、非简单请求（预检请求）。</li></ol> <h5 id="http2-0-https"><a href="#http2-0-https" class="header-anchor">#</a> http2.0/https</h5> <ol><li>http2.0 的升级：二进制传输，多路复用，头部压缩，服务器推送。
<ul><li>头部压缩：两端建立哈希表，只需要传输索引就能知道传输字段。</li> <li>多路复用：http1.x ，在 tcp 的长链接中，会队头阻塞。http2 使用了二进制帧来进行传输，并且不像明文存在顺序问题，所以无需排队等待。</li> <li>服务器推送：可以主动推送内容，如请求 html，主动推送相关资源，客户端减少等待。</li></ul></li> <li>https：建立在 SSL/TLS 协议上的 http 协议，证书颁发，非对称加密，报文进行的是对称加密。
<ol><li>加密过程（对称加密和非对称加密）：server 持有私钥A和公钥A，公钥明文传送给浏览器，浏览器随机生成对称加密秘钥 X，用公钥A 加密 X 传送给 server，这样两端都有秘钥 X，传输过程中就能加密，并且秘钥 X 经过了非对称加密，能保证安全。</li> <li>中间人攻击：利用浏览器无法知道公钥是网站的公钥，中间人拦截 server 的公钥 A，中间人用公钥 B 替换，得到 B 加密后的秘钥 X，然后解密，再用 A 加密传回 server 端，中间人得到了明文加密秘钥 X，并且两端没有察觉。</li> <li>CA 证书：证书由信任机构颁发，避免上述中间人拦截问题，证书中包含公钥和私钥，对明文 T 进行 hash 然后私钥加密得到签名 S。浏览器得到证书对 T 进行证书指定的 hash，然后签名 S 用公钥解密，两者值相等说明证书没有被篡改。（hash 作用是性能的优化）</li></ol></li></ol> <h5 id="安全相关"><a href="#安全相关" class="header-anchor">#</a> 安全相关</h5> <ol><li><p>CSRF：跨站请求伪装</p> <ol><li>原理：攻击者伪装用户对网站进行恶意操作。</li> <li>防范：SameSite 设置；登录时 token + cookie 双重认证，同源检测。</li></ol></li> <li><p>XSS：跨站脚本攻击</p> <ol><li>原理：恶意代码注入</li> <li>类型：反射型，注入型，Dom 型。</li> <li>防范：前后端对用户输入转译，CSP规则开启，HttpOnly 开启。</li></ol></li></ol> <h5 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h5> <ol><li>tcp 和 udp 的区别：todo</li> <li>WebSocket 应用：扫码上传图片？</li> <li>跨域的方式：
<ol><li>CORS：简单请求，非简单请求（预检）。</li></ol></li> <li>分片上传？</li> <li>DNS：
<ol><li>概念：根域名，顶级域名，次级域名</li> <li>查找过程：分级查找，</li></ol></li> <li>CDN（内容分发网络）：
<ol><li>目的：加速请求，保证服务的可用性，降低了源站的压力。</li> <li>过程：1. 应用了 CDN 之后，请求网站后， DNS 解析到 CNAME （CDN 专用 DNS），再指向了 CDN 的负载均衡系统，根据用户的 IP ，运营商和节点负载状况，返回最合适的节点给用户访问。</li> <li>指标：命中率：命中缓存；回源率：访问源站；</li></ol></li></ol> <h4 id="工程化"><a href="#工程化" class="header-anchor">#</a> 工程化</h4> <h5 id="monorepo"><a href="#monorepo" class="header-anchor">#</a> monorepo</h5> <ol><li>yarn workspace：处理依赖问题。
<ol><li>根目录初始化：指定 private: true，workspaces 的路径。</li> <li>yarn install：会将指定的 workspace 都放到顶层 node_modules。</li> <li>依赖提升，公用的依赖会放到顶层的 node_modules。</li> <li>安装依赖：根目录；所有子包安装；特定子包安装。</li></ol></li> <li>lerna：和 yarn workspace 很多能力重合，最佳实践应该是处理发布问题。</li> <li>在业务中的实践：
1. 发布时包的裁剪，降低 npm 包安装时间。
2. shared 机制。
3. branchformat。</li></ol> <h5 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h5> <ol><li>流程概述：
<ol><li>将命令行参数，配置参数等合并校验，然后开始准备 Compiler 对象，初始化编译环境</li> <li>开始从 Entry 开始，递归寻找对应的依赖模块， 使用对应的 Loader 进行编译。</li> <li>完成了编译之后，将编译完成的 chunks 输出到文件系统。</li></ol></li> <li>tapable 简介：订阅发布系统的实现，以 hook 呈现，包括了同步，异步钩子，并且有Bail，WaterFall，Loop，Parallel，Series 等针对回调返回值的调度。</li> <li>loader 和 plugin：loader 是在编译的过程中起到转译的作用。plugin 在编译的过程中，可以在各个阶段做不同事项的处理，是一个广播和订阅的过程。</li> <li>构建速度优化：
<ol><li>resolve 优化：缩小查找范围，resolve.modules 指定依赖路径，减少层级搜索。</li> <li>noParse：指定无需处理的模块。</li> <li>指定extensions：减少文件查找。</li> <li>DLLPlugin，DLLReferencePlugin：将第三方依赖打入 dll 文件中，省去多次打包。</li> <li>HappyPack：多进程 Loader 转换。</li></ol></li></ol> <h5 id="vite"><a href="#vite" class="header-anchor">#</a> vite</h5> <ol><li>bundleless：</li> <li>大致原理：</li></ol> <h5 id="rollup"><a href="#rollup" class="header-anchor">#</a> rollup</h5> <ol><li>介绍一下：</li></ol> <h5 id="babel"><a href="#babel" class="header-anchor">#</a> babel</h5> <ol><li>AST：抽象语法树，源码语法结构的表示。
<ol><li>流程：1. 词法分析 scanner，生成 tokens，扁平的语法片段数组；2.语法分析，使用 parser 生成 ast；3. 对 ast 进行深度优先遍历，生成新的 ast；4. generator 将新 ast 转换成代码。</li></ol></li></ol> <h5 id="typescript"><a href="#typescript" class="header-anchor">#</a> typescript</h5> <ol><li>ts-loader：ts 文件处理，调用 tsc，transpileOnly 默认 false，改为 true 不做类型检查，加快编译速度。</li> <li>类型检测：fork-ts-checker-webpack-plugin，单启进程进行 ts 类型检测，上述方案的补充。</li> <li>ts-loader 和 babel 的关系：babel7 处理 ts 只做编译，抛弃类型。需要 ts-loader 和 babel 二选一，最佳实践：ts-loader 编译 ts 为 js，babel 再接手，配合上述2。</li></ol> <h5 id="工作流规范"><a href="#工作流规范" class="header-anchor">#</a> 工作流规范</h5> <ol><li>git 相关：
<ol><li>commit 信息校验：@commitlint/cli，@commitlint/config-conventional（lint 的规则）。</li> <li>提交规范 commit 信息 cli：commitizen，git cz 或者 package.json 中配置 commit script。cz-conventional-changelog，conventional-changelog-cl。</li> <li>git hooks：husky 配置 commit-msg 钩子做 commit 信息的 lint，可以配置 pre-commit 做 lint-staged。</li></ol></li> <li>eslint / prettier 相关：
<ol><li>eslint 做代码 lint 检测，prettier 做代码格式化。冲突解决：eslint-config-prettier，eslint-plugin-prettier。</li> <li>typescript 的 lint 配置相关，plugin 和 parser。</li> <li>vue 文件的 lint 支持：vue-eslint-parser。</li></ol></li> <li>npm semver （语义化版本更新）：breaking change 更新 major，feature 更新 minor，bugfix 更新 patch，预发布更新 prerelease。</li></ol> <h4 id="前端领域方案"><a href="#前端领域方案" class="header-anchor">#</a> 前端领域方案</h4> <h5 id="错误监控"><a href="#错误监控" class="header-anchor">#</a> 错误监控</h5> <ol><li>错误类型：JS 错误，Ajax 错误，资源加载错误，Promise 抛出错误。</li> <li>怎么去捕获：onerror，error 事件，拦截xhr，fetch，unhandledrejection 事件，vue 的 errorHandler。</li></ol> <h5 id="性能监控"><a href="#性能监控" class="header-anchor">#</a> 性能监控</h5> <ol><li>性能指标，如何获取：
1.</li> <li>Web 应用性能优化手段</li></ol> <h5 id="前端埋点"><a href="#前端埋点" class="header-anchor">#</a> 前端埋点</h5> <h5 id="ui自动化测试"><a href="#ui自动化测试" class="header-anchor">#</a> UI自动化测试</h5> <ol><li>利用 puppeteer (headless浏览器) 来模拟人工操作，然后断言结果。</li> <li>用户操作路径录制如何做，chrome 已经有支持。</li></ol> <h5 id="微前端"><a href="#微前端" class="header-anchor">#</a> 微前端</h5> <ol><li><p>背景：多团队参与，跨技术栈整合，巨石应用的分解。解决的是可控体系下前端协同开发的问题。</p></li> <li><p>常见方案：single-spa 类型，web-components，module federation 等。</p></li> <li><p>针对业务的整体解决方案：</p> <ol><li>主子应用运营管理：建设平台，管理</li> <li>DevOps 建设</li> <li>子应用性能/安全监控</li> <li>容灾机制
<ol><li>子应用入口加载重试</li> <li>CDN 容灾</li></ol></li></ol></li> <li><p>运行时组合需要解决的问题：</p> <ol><li>子应用加载、切换</li> <li>隔离和通信</li></ol></li> <li><p>常见问题：</p></li> <li><p>样式隔离 ：</p> <ol><li>qiankun 使用了 html entry，会将子应用整个 dom 树都挂载在指定节点，所以也包含样式表。在子应用加载和卸载时，样式也会一起，天然形成了隔离。</li> <li>qiankun 内部提供了两种 css 沙箱：1. 利用 shadom dom；2. 类似 vue 的 scoped style，给全局样式加上 data 属性。</li></ol></li> <li><p>Js 沙箱：</p></li> <li><p>SnapshotSandbox：子应用加载启动之后，记录全局变量状态，卸载的时候做 diff，恢复快照。进去都遍历一次 window，性能差。</p></li> <li><p>Proxy 沙箱：</p> <ol><li>LegacySandbox：单例沙箱，利用 Proxy 记录每次 window 上变更和新增的值，卸载时候恢复原状，还是会污染 window。</li> <li>ProxySandbox：多实例沙箱，利用 Proxy 来代理全局对象，不会污染 window。</li></ol></li></ol> <h5 id="持续集成-交付"><a href="#持续集成-交付" class="header-anchor">#</a> 持续集成/交付</h5> <h5 id="低代码"><a href="#低代码" class="header-anchor">#</a> 低代码</h5></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c939f5a5.js" defer></script><script src="/assets/js/2.24b011f1.js" defer></script><script src="/assets/js/7.2d3061fb.js" defer></script>
  </body>
</html>
